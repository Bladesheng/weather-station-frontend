{"version":3,"file":"sw.js","mappings":"mBASA,MAAMA,EAAY,kCACZC,EAAe,CAAC,IAAK,cAAe,UAAW,eAAgB,yBAE1C,yBAAvBC,KAAKC,SAASC,MAChBH,EAAaI,SAAQ,CAACC,EAAaC,KACjCN,EAAaM,GAAS,4BAA4BD,GAAa,IAMnEJ,KAAKM,iBAAiB,WAAYC,IAChCA,EAAEC,UACA,WACE,MAAMC,QAAcC,OAAOC,KAAKb,GAChCc,QAAQC,IAAI,kEACNJ,EAAMK,OAAOf,EACpB,EAJD,GAKD,IAIHC,KAAKM,iBAAiB,SAAUC,IAC9B,MAAMQ,EAAM,IAAIC,IAAIT,EAAEU,QAAQF,KACxBG,EAAqBnB,EAAaoB,SAASJ,EAAIK,UAC/CC,EAA2C,UAA1Bd,EAAEU,QAAQK,aAE7BJ,GAAsBG,IACxBd,EAAEgB,YACA,WACEX,QAAQC,IAAI,2BAA2BN,EAAEU,QAAQF,OAEjD,MAAMN,QAAcC,OAAOC,KAAKb,GAC1B0B,QAAuBf,EAAMgB,MAAMlB,EAAEU,SAC3C,GAAIO,EACF,OAAOA,EAIT,MAAME,QAAwBC,MAAMpB,EAAEU,SAGtC,OAFAL,QAAQC,IAAI,8BAA8BN,EAAEU,QAAQF,OACpDN,EAAMmB,IAAIrB,EAAEU,QAASS,EAAgBG,SAC9BH,CACR,EAdD,IAkBAX,EAAIK,SAGJL,EAAIK,Q,IAMVpB,KAAKM,iBAAiB,YAAaC,IACjCK,QAAQC,IAAI,sCACZN,EAAEC,UACA,WACE,MAAMsB,QAAmBpB,OAAOqB,OAChC,IAAK,MAAMC,KAAqBF,EAC1BE,IAAsBlC,IACxBc,QAAQC,IAAI,4BAA4BmB,KACxCtB,OAAOuB,OAAOD,GAGnB,EARD,GASD,G","sources":["webpack://weather-station-frontend/./src/workers/sw.ts"],"sourcesContent":["// https://github.com/microsoft/TypeScript/issues/14877\n// https://stackoverflow.com/questions/63154992/how-to-get-serviceworker-registration-object-which-is-typescript-friendly\nexport {}; // export empty object because of tsc --isolatedModules flag\ndeclare const self: ServiceWorkerGlobalScope;\n\n// This number is changed by webpack everytime a new build is made.\n// New cache name forces wipe of the old cache and reload of all precached assets.\ndeclare const BUILD_NUMBER: string;\n\nconst cacheName = `meteostanice-pwa-v${BUILD_NUMBER}`;\nconst filesToCache = [\"/\", \"/index.html\", \"/app.js\", \"/favicon.ico\", \"/manifest.webmanifest\"];\n\nif (self.location.host === \"bladesheng.github.io\") {\n  filesToCache.forEach((relativeUrl, index) => {\n    filesToCache[index] = `/weather-station-frontend${relativeUrl}`;\n    // because the website is not hosted at the root but at \"/weather-station-frontend\"\n  });\n}\n\n// Install the service worker and cache all of the app's content\nself.addEventListener(\"install\", (e) => {\n  e.waitUntil(\n    (async () => {\n      const cache = await caches.open(cacheName);\n      console.log(\"[SW] Installing new service worker and caching all files\");\n      await cache.addAll(filesToCache);\n    })()\n  );\n});\n\n// Serve cached content when offline\nself.addEventListener(\"fetch\", (e) => {\n  const url = new URL(e.request.url);\n  const isPrecachedRequest = filesToCache.includes(url.pathname);\n  const isImageRequest = e.request.destination === \"image\";\n\n  if (isPrecachedRequest || isImageRequest) {\n    e.respondWith(\n      (async () => {\n        console.log(`[SW] Fetching resource: ${e.request.url}`);\n        // go to the cache first and return a cached response if we have one\n        const cache = await caches.open(cacheName);\n        const cachedResponse = await cache.match(e.request);\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        // otherwise, hit the network and add the network response to the cache for later visits\n        const fetchedResponse = await fetch(e.request);\n        console.log(`[SW] Caching new resource: ${e.request.url}`);\n        cache.put(e.request, fetchedResponse.clone());\n        return fetchedResponse;\n      })()\n    );\n  }\n\n  if (url.pathname === \"/api/readings/events\") {\n    // TODO: handle SSE\n  }\n  if (url.pathname === \"/api/readings/range\") {\n    // TODO: handle api calls\n  }\n});\n\n// cleanup old unused caches\nself.addEventListener(\"activate\", (e) => {\n  console.log(\"[SW] Activating new service worker\");\n  e.waitUntil(\n    (async () => {\n      const cacheNames = await caches.keys();\n      for (const selectedCacheName of cacheNames) {\n        if (selectedCacheName !== cacheName) {\n          console.log(`[SW] Deleting old cache: ${selectedCacheName}`);\n          caches.delete(selectedCacheName);\n        }\n      }\n    })()\n  );\n});\n"],"names":["cacheName","filesToCache","self","location","host","forEach","relativeUrl","index","addEventListener","e","waitUntil","cache","caches","open","console","log","addAll","url","URL","request","isPrecachedRequest","includes","pathname","isImageRequest","destination","respondWith","cachedResponse","match","fetchedResponse","fetch","put","clone","cacheNames","keys","selectedCacheName","delete"],"sourceRoot":""}